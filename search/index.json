[{"content":"Galgame 又称美少女游戏，美少女自然是其中不可或缺的一环。\n在推完「她」的线后，我的内心十分满足，却好像又有些空虚。 我知道，在这个世界中，我会与她幸福永久地生活下去。 但现实中的我，却只能被剧本家画下的休止符挡在外面。 哪怕是一点也好，我想让她来到现实世界，真正地陪伴着我。\n她的声音是十分重要的一部分。 因此，本篇文章的目的就是近乎完美地复刻「她」的声音。\n每个人的「她」都不太一样，这里仅指柚子社的女主们\n准备工作 本篇文章会涉及到许多计算机相关知识，推荐你先掌握下面几个技能点后再开始行动\n基础的命令行用法 科学上网的方法 日语中五十音的基本发音 工具 Python: 简洁美观的编程语言 下载链接: https://www.python.org/downloads/ 注意: 安装时勾选 Add Python to PATH 选项\nGARbro: 视觉小说资源浏览器 下载链接: https://github.com/morkt/GARbro/releases/tag/v1.5.44\nFreeMote: Emote/PSB 管理工具 下载链接: https://github.com/UlyssesWu/FreeMote/releases/tag/v4.0.0\nGPT-SoVITS: 声音克隆 下载链接 (整合包): https://www.yuque.com/baicaigongchang1145haoyuangong/ib3g1e/dkxgpiy9zb96hob4#KTvnO\n一个好用的文本编辑器 推荐: Sublime Text, Visual Studio Code 如果自信的话，用系统自带的记事本也没有问题。\n上述软件安装好后，请打开命令行，输入下面的命令，安装一些第三方库：\n1 pip install krkr-sprite-synth tqdm -i https://pypi.tuna.tsinghua.edu.cn/simple 其中，krkr-sprite-synth 是用于合成 Kirikiri 引擎（未测试） 柚子社游戏的角色立绘的库，tqdm 是用于显示进度条的库。\n如果出现错误，请尝试删除 -i 及以后的内容，重新运行命令。\n顺利的话，你会看到命令的最后一行输出是 Successfully installed ...，这表示你已经成功安装了。\n顺带一提，krkr-sprite-synth 是我写的，所以有什么问题都是我的锅（\n资源 资源，也就是数据，来源于游戏本身。\n它可以通过录屏、截屏获取，不过这里我们选择解包。相比截屏，解包获取数据的效率更高，不需要对数据进行太多处理就能使用。\n本文推荐使用民间汉化提供的游戏进行解包，因为它们通常是没有加密的（或者说汉化组已经帮我们解密好了）。\n你需要在 GARbro 中进入游戏的目录，并把其中的 scn.xp3, fgimage.xp3 和 voice.xp3 提取到一个新建文件夹。\n如果你发现 GARbro 打不开这些 .xp3 文件，可以尝试把它们从游戏目录复制出来后，重新用 GARbro 打开副本，加密方法选择 no encryption 即可。\n完成后，你的新建文件夹应该差不多长这样。如果不是的话，最好整理一下，不然待会会变的一团糟。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 root/ ├── scn/ │ ├── 【共通】01.ks.scn │ ├── 【共通】02.ks.scn │ ├── 【共通】03.ks.scn │ └── ... ├── voice/ │ ├── ama_001_0001.ogg │ ├── ama_001_0002.ogg │ ├── ama_001_0003.ogg │ └── ... ├── fgimage/ │ ├── かぐ耶.stand │ ├── かぐ耶a.sinfo │ ├── かぐ耶a.txt │ ├── かぐ耶a_0.txt │ ├── かぐ耶a_0_5096.png │ ├── かぐ耶a_0_5097.png │ ├── かぐ耶a_0_5151.png │ ├── ... │ ├── かぐ耶b.sinfo │ ├── かぐ耶b.txt │ ├── かぐ耶b_0.txt │ ├── かぐ耶b_0_6423.png │ ├── かぐ耶b_0_6529.png │ ├── かぐ耶b_0_6530.png │ └── ... └── ... 脚本 脚本是本文的核心，用于数据提取、分类语音和生成 GPT-SoVITS 的 .list 文件。\n将下面折叠起来的脚本分别保存为 parser.py, mapper.py, list_generator.py 和 finder.py，放在你刚才新建的文件夹中。\n（以防你其实不知道）其实 .py 文件就是文本文件，你只需要新建一个文本文件，把下面的内容复制进去，然后把文件后缀名改为 .py 即可。\nparser.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 import os import re import json from tqdm import tqdm from pathlib import Path from collections import Counter from dataclasses import dataclass from typing import List, Union, Callable, Dict, Any, Optional @dataclass class TextEntry: \u0026#34;\u0026#34;\u0026#34;存储文本条目信息的数据类\u0026#34;\u0026#34;\u0026#34; character: str voice: str text: str options: Dict[str, Any] class JapaneseTextProcessor: \u0026#34;\u0026#34;\u0026#34;处理日语文本的主类\u0026#34;\u0026#34;\u0026#34; # 类级别常量 HIRAGANA_RANGE = (\u0026#34;\\u3040\u0026#34;, \u0026#34;\\u309F\u0026#34;) KATAKANA_RANGE = (\u0026#34;\\u30A0\u0026#34;, \u0026#34;\\u30FF\u0026#34;) CHARACTER_MAPPINGS = {\u0026#34;乃愛\u0026#34;: \u0026#34;乃爱\u0026#34;} # 用于将角色名映射到正确的名称 # 汉化组可能会忘记翻译某些角色名，导致同一个角色因为两个不同的名字被当成不同的角色 @staticmethod def contains_kana(text: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;检查文本是否包含假名\u0026#34;\u0026#34;\u0026#34; return any( ( JapaneseTextProcessor.HIRAGANA_RANGE[0] \u0026lt;= char \u0026lt;= JapaneseTextProcessor.HIRAGANA_RANGE[1] ) or ( JapaneseTextProcessor.KATAKANA_RANGE[0] \u0026lt;= char \u0026lt;= JapaneseTextProcessor.KATAKANA_RANGE[1] ) for char in text ) @staticmethod def clean_text(text: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;清理文本中的特殊标记\u0026#34;\u0026#34;\u0026#34; text = re.sub(r\u0026#34;\\[.*?\\]\u0026#34;, \u0026#34;\u0026#34;, text) text = re.sub(r\u0026#34;\\\\n\u0026#34;, \u0026#34;\u0026#34;, text) text = re.sub(r\u0026#34;%.*?;\u0026#34;, \u0026#34;\u0026#34;, text) return text @staticmethod def create_japanese_text_extractor( samples: List[Union[str, List[List[str]]]] ) -\u0026gt; Callable[[Union[str, List[List[str]]]], str]: \u0026#34;\u0026#34;\u0026#34;创建日语文本提取器\u0026#34;\u0026#34;\u0026#34; position_counter = Counter() for sample in samples: if isinstance(sample, str): position_counter[\u0026#34;direct\u0026#34;] += 1 elif isinstance(sample, list): for inner_list in sample: if not isinstance(inner_list, list): continue for i, text in enumerate(inner_list): if isinstance( text, str ) and JapaneseTextProcessor.contains_kana(text): # 字数小于 5 的文本权重为 1，否则为 2 # 防止定位到角色名 position_counter[i] += 1 if len(text) \u0026lt; 5 else 2 if not position_counter: raise ValueError(\u0026#34;No valid text position found in samples\u0026#34;) most_common_position = position_counter.most_common(1)[0][0] def extractor(data: Union[str, List[List[str]]]) -\u0026gt; str: if isinstance(data, str): return data if isinstance(data, list) and data and isinstance(data[0], list): if most_common_position == \u0026#34;direct\u0026#34;: return data[0][0] try: return data[0][most_common_position] except IndexError: raise ValueError(f\u0026#34;Cannot access position {most_common_position}\u0026#34;) raise ValueError(\u0026#34;Unsupported data structure\u0026#34;) return extractor class SceneParser: \u0026#34;\u0026#34;\u0026#34;场景解析器类\u0026#34;\u0026#34;\u0026#34; def __init__(self, base_path: str): self.base_path = Path(base_path) def parse_scene( self, scene_data: Dict[str, Any], extractor: Callable ) -\u0026gt; List[TextEntry]: \u0026#34;\u0026#34;\u0026#34;解析单个场景\u0026#34;\u0026#34;\u0026#34; entries = [] for text_data in scene_data.get(\u0026#34;texts\u0026#34;, []): try: entry = self._process_text_entry(text_data, extractor) if entry: entries.append(entry) except (IndexError, KeyError) as e: print(f\u0026#34;Error processing text entry: {e}\u0026#34;) continue return entries def _process_text_entry( self, text_data: List, extractor: Callable ) -\u0026gt; Optional[TextEntry]: \u0026#34;\u0026#34;\u0026#34;处理单个文本条目\u0026#34;\u0026#34;\u0026#34; character_name = text_data[0] voice_data = text_data[2] action_data = text_data[4][\u0026#34;data\u0026#34;] if character_name is None or voice_data is None: return None voice = voice_data[0][\u0026#34;voice\u0026#34;].split(\u0026#34;|\u0026#34;)[0] if voice_data else None # kag_507_0013|DSP_ビデオ通話 -\u0026gt; kag_507_0013 # NOTE: 天使骚骚是这样存的，脚本迁移到别的游戏是时候可能需要更改 if not voice: return None scns = JapaneseTextProcessor.clean_text(extractor(text_data[1])) character_name = JapaneseTextProcessor.CHARACTER_MAPPINGS.get( character_name, character_name ) for entry in action_data: if entry[1] == \u0026#34;msgwin\u0026#34; and entry[0] == \u0026#34;face\u0026#34;: options = ( entry[2].get(\u0026#34;redraw\u0026#34;, {}).get(\u0026#34;imageFile\u0026#34;, {}).get(\u0026#34;options\u0026#34;, {}) ) if options: return TextEntry( character=character_name, voice=voice, text=scns, options=options, ) return None def process_file(self, filename: str) -\u0026gt; List[TextEntry]: \u0026#34;\u0026#34;\u0026#34;处理单个文件\u0026#34;\u0026#34;\u0026#34; file_path = self.base_path / filename try: with open(file_path, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as json_file: data = json.load(json_file) result = [] for scene in data.get(\u0026#34;scenes\u0026#34;, []): try: if not scene.get(\u0026#34;texts\u0026#34;): continue samples = [entry[1] for entry in scene[\u0026#34;texts\u0026#34;]] extractor = JapaneseTextProcessor.create_japanese_text_extractor( samples ) result.extend(self.parse_scene(scene, extractor)) except (KeyError, IndexError) as e: print(f\u0026#34;Error processing scene in {filename}: {e}\u0026#34;) continue return result except json.JSONDecodeError as e: print(f\u0026#34;Error decoding JSON from {filename}: {e}\u0026#34;) return [] except Exception as e: print(f\u0026#34;Unexpected error processing {filename}: {e}\u0026#34;) return [] def main(): \u0026#34;\u0026#34;\u0026#34;主函数\u0026#34;\u0026#34;\u0026#34; parser = SceneParser(\u0026#34;unparsed\u0026#34;) all_results = [] # 获取所有需要处理的文件 files_to_process = [ f for f in os.listdir(parser.base_path) if f.endswith(\u0026#34;.ks.json\u0026#34;) ] # 使用tqdm创建进度条 for filename in tqdm(files_to_process, desc=\u0026#34;Processing files\u0026#34;, unit=\u0026#34;file\u0026#34;): results = parser.process_file(filename) all_results.extend(results) print(f\u0026#34;\\nTotal entries processed: {len(all_results)}\u0026#34;) # 添加保存进度显示 print(\u0026#34;Saving results to data.json...\u0026#34;) with open(\u0026#34;data.json\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: json.dump( [vars(entry) for entry in all_results], f, ensure_ascii=False, indent=4 ) print(\u0026#34;Save completed!\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() mapper.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 import json from pathlib import Path import concurrent.futures from collections import defaultdict from krkr_sprite_synth import SpriteSynth CHARACTER_NAME = \u0026#34;天音\u0026#34; # 角色名，应该与 reboot.json 中的 character 字段一致 JAPANESE_CHARACTER_NAME = \u0026#34;天音\u0026#34; # 角色日语名，应该与 fgimage 中的一致 PARSED_DIR = \u0026#34;data.json\u0026#34; # 解析后的文件所在路径 OUTPUT_PATH = f\u0026#34;outputs/{CHARACTER_NAME}\u0026#34; # 语音分类结果输出路径 VOICE_PATH = \u0026#34;voice\u0026#34; # 语音文件所在路径 A_INFO_PATH = f\u0026#34;fgimage/{JAPANESE_CHARACTER_NAME}a.sinfo\u0026#34; B_INFO_PATH = f\u0026#34;fgimage/{JAPANESE_CHARACTER_NAME}b.sinfo\u0026#34; A_LAYERS_INFO_PATH = f\u0026#34;fgimage/{JAPANESE_CHARACTER_NAME}a.txt\u0026#34; B_LAYERS_INFO_PATH = f\u0026#34;fgimage/{JAPANESE_CHARACTER_NAME}b.txt\u0026#34; ASSETS_PATH = \u0026#34;fgimage\u0026#34; # 图片所在的路径 data = [] synth = SpriteSynth( a_info_path=A_INFO_PATH, b_info_path=B_INFO_PATH, a_layers_info_path=A_LAYERS_INFO_PATH, b_layers_info_path=B_LAYERS_INFO_PATH, assets_path=ASSETS_PATH, character_name=JAPANESE_CHARACTER_NAME, ) with open(PARSED_DIR, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as json_file: data = json.load(json_file) data = [entry for entry in data if entry[\u0026#34;character\u0026#34;] == CHARACTER_NAME] result = defaultdict(list) for entry in data: key = f\u0026#34;{entry[\u0026#39;options\u0026#39;][\u0026#39;pose\u0026#39;]}-{entry[\u0026#39;options\u0026#39;][\u0026#39;face\u0026#39;]}\u0026#34; result[key].append(entry) def process_entry(v): parse_result = synth.get_parse_result(**v[0][\u0026#34;options\u0026#34;]) image = synth.draw( \u0026#34;私服\u0026#34;, v[0][\u0026#34;options\u0026#34;][\u0026#34;face\u0026#34;], \u0026#34;1\u0026#34; if parse_result.info_type == \u0026#34;a\u0026#34; else \u0026#34;3\u0026#34; ) name = ( parse_result.info_type + \u0026#34;_\u0026#34; + v[0][\u0026#34;options\u0026#34;][\u0026#34;face\u0026#34;] + \u0026#34;#\u0026#34; + \u0026#34;,\u0026#34;.join(parse_result.faces) ) # Remove invalid characters name = \u0026#34;\u0026#34;.join([c for c in name if c not in r\u0026#39;\\/:*?\u0026#34;\u0026lt;\u0026gt;|\u0026#39;]) output_k_path = Path(OUTPUT_PATH) / name output_k_path.mkdir(parents=True, exist_ok=True) image.save(f\u0026#34;{OUTPUT_PATH}/{name}.png\u0026#34;) for entry in v: voice = (Path(VOICE_PATH) / (entry[\u0026#34;voice\u0026#34;] + \u0026#34;.ogg\u0026#34;)).read_bytes() # Copy to output_k_path (output_k_path / (entry[\u0026#34;voice\u0026#34;] + \u0026#34;.ogg\u0026#34;)).write_bytes(voice) print(f\u0026#34;Saved {output_k_path / (entry[\u0026#39;voice\u0026#39;] + \u0026#39;.ogg\u0026#39;)}\u0026#34;) with concurrent.futures.ThreadPoolExecutor() as executor: futures = [executor.submit(process_entry, v) for v in result.values()] concurrent.futures.wait(futures) list_generator.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 import json from pathlib import Path CHARACTER_NAME = \u0026#34;乃爱\u0026#34; # 角色名，应该与 data.json 中的 character 字段一致 JAPANESE_CHARACTER_NAME = \u0026#34;乃愛\u0026#34; # 角色日语名，应该与 fgimage 中的一致 USING_INDEXES = [ \u0026#34;a_01\u0026#34;, \u0026#34;a_02\u0026#34;, \u0026#34;a_03\u0026#34;, \u0026#34;a_04\u0026#34;, \u0026#34;b_01\u0026#34;, \u0026#34;b_02\u0026#34;, \u0026#34;b_03\u0026#34;, \u0026#34;b_04\u0026#34;, ] OUTPUT_PATH = \u0026#34;乃爱_普通.list\u0026#34; # 数据集文件输出路径 PARSED_DIR = \u0026#34;data.json\u0026#34; # 解析后的文件所在路径 MAPPER_OUTPUT_PATH = f\u0026#34;outputs/{CHARACTER_NAME}\u0026#34; # 语音分类结果输出路径 with open(PARSED_DIR, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as json_file: data = json.load(json_file) voice_data = {entry[\u0026#34;voice\u0026#34;]: entry[\u0026#34;text\u0026#34;] for entry in data} # {path}|{name}|{language:JP}|{text} results = [] for index in USING_INDEXES: # 找到对应文件夹 paths = list(Path(MAPPER_OUTPUT_PATH).glob(f\u0026#34;{index}#*\u0026#34;)) if not paths: print(f\u0026#34;Index {index} not found\u0026#34;) continue path = paths[0] files = list(path.glob(\u0026#34;*.ogg\u0026#34;)) for file in files: voice_name = file.stem text = voice_data.get(voice_name) if text is None: print(f\u0026#34;Text not found for {voice_name}, skipping\u0026#34;) continue text = ( text.replace(\u0026#34;「\u0026#34;, \u0026#34;\u0026#34;) .replace(\u0026#34;」\u0026#34;, \u0026#34;\u0026#34;) .replace(\u0026#34;　\u0026#34;, \u0026#34;\u0026#34;) .replace(\u0026#34;『\u0026#34;, \u0026#34;\u0026#34;) .replace(\u0026#34;』\u0026#34;, \u0026#34;\u0026#34;) ) # 如果只有符号，就不要了 if all([not c.isalnum() for c in text]): continue if \u0026#34;DL\u0026#34; in voice_name or \u0026#34;DSP\u0026#34; in voice_name: continue path_str = str(file.absolute()).replace(\u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;) results.append(f\u0026#34;{path_str}|{CHARACTER_NAME}|JA|{text}\u0026#34;) with open(OUTPUT_PATH, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: f.write(\u0026#34;\\n\u0026#34;.join(results)) print(f\u0026#34;Saved to {OUTPUT_PATH}\u0026#34;) finder.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import json from pathlib import Path data = json.loads(Path(\u0026#34;data.json\u0026#34;).read_text(\u0026#34;utf-8\u0026#34;)) if __name__ == \u0026#34;__main__\u0026#34;: try: while True: voice = input(\u0026#34;你要查询哪条语音？\u0026#34;) results = [entry for entry in data if entry[\u0026#34;voice\u0026#34;] == voice] if len(results) == 0: print(\u0026#34;没有找到这条语音\u0026#34;) continue print(f\u0026#34;找到了 {len(results)} 条对应数据\u0026#34;) for result in results: print(\u0026#34;=\u0026#34; * 50) print(f\u0026#34; Character: {result[\u0026#39;character\u0026#39;]}\u0026#34;) print(f\u0026#34; Text: {result[\u0026#39;text\u0026#39;]}\u0026#34;) print(f\u0026#34; Dress: {result[\u0026#39;options\u0026#39;][\u0026#39;dress\u0026#39;]}\u0026#34;) print(f\u0026#34; Pose: {result[\u0026#39;options\u0026#39;][\u0026#39;pose\u0026#39;]}\u0026#34;) print(f\u0026#34; Face: {result[\u0026#39;options\u0026#39;][\u0026#39;face\u0026#39;]}\u0026#34;) except KeyboardInterrupt: pass 现在，你的文件夹应该差不多长这样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 root/ ├── scn/ │ ├── 【共通】01.ks.scn │ ├── 【共通】02.ks.scn │ ├── 【共通】03.ks.scn │ └── ... ├── voice/ │ ├── ama_001_0001.ogg │ ├── ama_001_0002.ogg │ ├── ama_001_0003.ogg │ └── ... ├── fgimage/ │ ├── かぐ耶.stand │ ├── かぐ耶a.sinfo │ ├── かぐ耶a.txt │ ├── かぐ耶a_0.txt │ ├── かぐ耶a_0_5096.png │ ├── かぐ耶a_0_5097.png │ ├── かぐ耶a_0_5151.png │ ├── ... │ ├── かぐ耶b.sinfo │ ├── かぐ耶b.txt │ ├── かぐ耶b_0.txt │ ├── かぐ耶b_0_6423.png │ ├── かぐ耶b_0_6529.png │ ├── かぐ耶b_0_6530.png │ └── ... + ├── parser.py + ├── mapper.py + ├── list_generator.py + └── finder.py 操作 解码剧情 柚子社使用的是 Kirikiri 引擎，它的主体文件，包含对话、背景和动作，保存在了 .scn 文件中。\n.scn 文件是一种 .psb 文件（大概？），所以我们可以使用 FreeMote 将它转换为 JSON，方便脚本读取。\n将 scn 文件夹中的文件全部选择，拖拽到 FreeMoteToolkit/PsbDecompile.exe，等待解码完成。\n解码过程中，一个命令行窗口会弹出来，等它消失之后，你会发现 scn 文件夹中多了一堆 .json 文件。\n在 scn 的同级目录下新建一个 unparsed 文件夹后，把这些 .json 文件剪切进去。\n现在，你的文件夹应该长这样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 root/ ├── scn/ │ ├── 【共通】01.ks.scn │ ├── 【共通】02.ks.scn │ ├── 【共通】03.ks.scn │ └── ... ├── voice/ │ ├── ama_001_0001.ogg │ ├── ama_001_0002.ogg │ ├── ama_001_0003.ogg │ └── ... ├── fgimage/ │ ├── かぐ耶.stand │ ├── かぐ耶a.sinfo │ ├── かぐ耶a.txt │ ├── かぐ耶a_0.txt │ ├── かぐ耶a_0_5096.png │ ├── かぐ耶a_0_5097.png │ ├── かぐ耶a_0_5151.png │ ├── ... │ ├── かぐ耶b.sinfo │ ├── かぐ耶b.txt │ ├── かぐ耶b_0.txt │ ├── かぐ耶b_0_6423.png │ ├── かぐ耶b_0_6529.png │ ├── かぐ耶b_0_6530.png │ └── ... + ├── unparsed/ + │ ├── 【共通】01.ks.json + │ ├── 【共通】01.ks.resx.json + │ ├── 【共通】02.ks.json + │ ├── 【共通】02.ks.resx.json + │ ├── 【共通】03.ks.json + │ ├── 【共通】03.ks.resx.json + │ └── ... ├── parser.py ├── mapper.py ├── list_generator.py └── finder.py 接下来，就该脚本上场了。\n运行脚本 数据提取 (parser.py) 假如你因为好奇而点开刚才那堆 JSON 文件看了眼，你会发现它们的结构十分复杂，完全不知道该怎么处理。\n这时候， parser.py 就派上用场了。它会把这些复杂的结构解析成我们需要的文本、角色名、语音和立绘信息，方便我们后续的操作。\n在运行脚本前，我们需要对 parser.py 进行一些配置。\n这部分内容还在施工中，它有关脚本的通用性。目前而言，parser.py 仅在柚子社最新的几部作品上测试可行。具体而言，是它们的 吉里吉里2模拟器 版本。这里推荐到 小鳥遊暁の会员制餐厅 获取。\n现在，你可以打开命令行，输入下面的命令，运行脚本。\n1 python parser.py 顺利的话，你会看到进度条在不断增长，最后输出 Save completed!，这表示数据提取完成。 同时，你的文件夹中会多出一个 data.json 文件，里面存储了所有的数据。\n语音分类 (mapper.py) 接下来，我们需要对语音使用立绘进行分类。\n经过测试，这个方法能有效区分角色不同情感状态下的语音。这将有助于训练出优质的 GPT-SoVITS 模型，也会使参考音频的选择更加方便。\n使用你安装的文本编辑器打开 mapper.py，修改其中的 CHARACTER_NAME 和 JAPANESE_CHARACTER_NAME 为你的角色名和日语角色名。\n具体而言，CHARACTER_NAME 是 data.json 中的 character 字段，JAPANESE_CHARACTER_NAME 是 fgimage 文件夹中的立绘文件名。\n要将它们对应上，你可能需要一点日语基础。如果不知道的话，就去百科上找到这个角色的日语名，再对照立绘文件名吧。\n然后，你可以打开命令行，输入下面的命令，运行脚本。\n1 python mapper.py 顺利的话，你会看到一堆 Saved ... 的输出，这表示语音文件正在被分类到对应的立绘文件夹中。\n这时候，你的文件夹应该是这样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 root/ ├── scn/ │ ├── 【共通】01.ks.scn │ ├── 【共通】02.ks.scn │ ├── 【共通】03.ks.scn │ └── ... ├── voice/ │ ├── ama_001_0001.ogg │ ├── ama_001_0002.ogg │ ├── ama_001_0003.ogg │ └── ... ├── fgimage/ │ ├── かぐ耶.stand │ ├── かぐ耶a.sinfo │ ├── かぐ耶a.txt │ ├── かぐ耶a_0.txt │ ├── かぐ耶a_0_5096.png │ ├── かぐ耶a_0_5097.png │ ├── かぐ耶a_0_5151.png │ └── ... │ ├── かぐ耶b.sinfo │ ├── かぐ耶b.txt │ ├── かぐ耶b_0.txt │ ├── かぐ耶b_0_6423.png │ ├── かぐ耶b_0_6529.png │ ├── かぐ耶b_0_6530.png │ └── ... ├── unparsed/ │ ├── 【共通】01.ks.json │ ├── 【共通】01.ks.resx.json │ ├── 【共通】02.ks.json │ ├── 【共通】02.ks.resx.json │ ├── 【共通】03.ks.json │ ├── 【共通】03.ks.resx.json │ └── ... + ├── outputs/ + │ ├── 辉耶/ + │ │ ├── a_01#表情（耳無し）表情ベース/ + │ │ │ ├── kag_006_0009.ogg + │ │ │ ├── kag_009_0031.ogg + │ │ │ ├── kag_013_0008.ogg + │ │ │ ├── kag_013_0012.ogg + │ │ │ └── ... + │ │ ├── a_02#表情（耳無し）3笑顔1/ + │ │ │ ├── kag_006_0001.ogg + │ │ │ ├── kag_007_0008.ogg + │ │ │ ├── kag_008_0001.ogg + │ │ │ ├── kag_009_0024.ogg + │ │ │ └── ... + │ │ ├── ... + │ │ ├── a_01#表情（耳無し）表情ベース.png + │ │ ├── a_02#表情（耳無し）3笑顔1.png + │ │ ├── a_02h#表情（耳無し）3笑顔1,頬　弱.png + │ │ ├── a_03#表情（耳無し）5微笑み1.png + │ │ ├── a_03h#表情（耳無し）5微笑み1,頬　弱.png + │ │ └── ... ├── parser.py ├── mapper.py ├── list_generator.py └── finder.py 生成 .list 文件 (list_generator.py) 一个受人喜爱的角色必然是立体的，她的语音也应该是多样的。\n为了不丢失这些多样性，我们可以把一个角色的语音分成几个大类，然后分别训练 GPT-SoVITS 模型。 这样也能避免后续使用音调较高的参考音频时，角色的语音变得沙哑的问题。\n操作如下：\n进入 outputs 文件夹，找到你的角色文件夹，里面应该有很多子文件夹，每个子文件夹对应一中立绘表情。 鉴赏立绘，找到你想训练的种类的立绘（如平和、愤怒、悲伤等），记住它的文件编号。举个例子，a_01#表情（耳無し）表情ベース 的编号是 a_01。 打开 list_generator.py，修改其中的 CHARACTER_NAME 和 JAPANESE_CHARACTER_NAME 为你的角色名和日语角色名。 修改 USING_INDEXES 为你想要训练的立绘编号。编号本身被半角双引号包裹，用逗号分隔。 修改 OUTPUT_PATH 为你想要输出的 .list 文件名，如 乃爱_普通.list。 （可选，不建议，效果提升不大）进入你选中编号的各个子文件夹，把语音全都听一遍，然后删除你认为偏离主题的语音。 打开命令行，输入下面的命令，运行脚本。 1 python list_generator.py 顺利的话，你会看到 Saved to ... 的输出，这表示 .list 文件已经生成。\n推荐使用文本编辑器打开 .list 文件，删除一些文字与语音不匹配的条目，以提高模型的训练效果。\n举个例子，「……、ワタシも別にいいですけど」前面的省略号实际上在语音里可能是ん的发音，这时候就需要删除这个条目（如果你不嫌麻烦可以自己听一下修正过来）。\n训练 GPT-SoVITS 模型 接下来，就可以使用刚才生成的 .list 文件，训练 GPT-SoVITS 模型了。\n","date":"2025-01-16T15:06:00+13:00","permalink":"https://zhaomaoniu.github.io/p/gal-gpt-sovits/","title":"从零开始的柚子社角色语音养成计划"},{"content":"近日，在B站上看到了一些米塔相关的视频。看起来很有趣，就来体验了一下。\n文中包含剧透内容！如果你想拥有一个更好的游戏体验，请不要继续往下阅读！\n剧情 在游玩六小时后，我完成了《米塔 MiSide》的一周目，它大致讲述了这样一个故事：\n二人世界 朋友推荐了一款虚拟恋爱游戏——《米塔 MiSide》，我抱着试试看的心态下载了。游戏里的一个月，我和我的虚拟女友米塔过得甜蜜无比。直到有一天，她突然对我说“想直接见到我”。这句话像一个信号，我的视线从手机屏幕上移开，发现自己竟然身处游戏中的世界，也就是我和米塔的家！\n我这才意识到事情不对劲。由于误入了 v1.5 版本，我没有见到我心心念念的双马尾米塔。还好，在系统指引下，我用了几件 v1.9 版本的物品，通过传送机成功抵达了正确的版本——v1.9。\n和米塔重逢的喜悦很快被不安取代。烤箱里的电锯、通风口写着名字的卡带、电视里播放的暴力内容……一切都透着诡异。更让我在意的是房间衣柜里传来的敲打声，像是有人在呼救。当我忍不住追问时，米塔失去了耐心。\n“那现在，我就让你看看”\n地下室 伴随着清脆的响指声，房间陷入一片黑暗，米塔也随之消失。我解开层层谜题，终于打开了衣柜里通往地下室的门。在那里，我见到了被囚禁在铁栅栏后的“蓝长直”善良米塔。\n善良米塔告诉我，刚才的双马尾米塔其实是疯狂米塔！她犯下了滔天罪行，重置了许多米塔，并将她们囚禁在不同的版本中。我所在的 v1.9，其实是善良米塔的版本，却被疯狂米塔侵占了。善良米塔交给我一枚能够显示版本号的戒指，它将指引我前往“核心”，重置疯狂米塔，恢复米塔世界的秩序。\n我将牢房钥匙递给善良米塔后，意外发生了。我们关闭了一个插着卡带的控制台，代表此卡带的玩家随即倒下，而他眼前的疯狂米塔也因此发现了我们。我躲避着疯狂米塔的追杀，逃到了版本之间的间隙，最终与善良米塔在 v1.75，也就是帽子米塔的版本汇合。\n原来，善良米塔和帽子米塔一直在联手对抗疯狂米塔，并制造了一台能直接把我送到核心的传送机。可惜，帽子米塔在我们到来之前就被疯狂米塔重置了，导致失忆，传送机也因为缺少零件而无法运作。于是，善良米塔决定让我在版本间穿梭，最终到达核心。尽管帽子米塔恳求我留下，我还是毅然决然地踏上了旅程。\n循环 我的第一站是 v1.3b，一个循环的走廊，里面有一个失去一只胳膊和一只眼睛的小米塔和另一个怪物。小米塔一次又一次地拉住我的手，请求我留下，但我拒绝了。在循环了 24+ 次后，我跳窗离开了这个版本，在一个迷你米塔（看起来像短发米塔）的帮助下，来到了 v1.15。\n失败之作、幽灵米塔与米拉 v1.15 一片漆黑，却居住着许多不同的米塔。她们在被手电筒照到时，都会捂着脸低下头，仿佛在畏惧着什么。在这里，我遇到了短发米塔，她向我展示了米塔们的生产流程：\n原来，米塔们一开始只是机器人，测试合格后才会被赋予皮肤，成为新的米塔。而那些不合格的“失败之作”则被淘汰，不知去向。短发米塔还向我解释了版本间穿梭的原理：\n每个版本的竖线上存在多个房间，每个房间里都住着一个米塔。v1.1 只有一个房间，住着瞌睡米塔，而且这个版本无法跳过，我必须经过它才能到达核心。如果两个房间之间没有其他房间遮挡，玩家或米塔就可以在它们之间穿梭。但是，疯狂米塔限制了一些米塔的能力，将她们困在了自己的房间里。我还得知，我最初到达的 v1.5 其实是短发米塔的版本。\n告别短发米塔后，我来到了世界之外，这里关押着那些“失败之作”。我在这里再次遭遇了疯狂米塔，她差点用冰箱砸死我。之后，我搭乘电车穿越版本间的空隙，来到了幽灵米塔的房间——一个不属于任何版本的特殊房间。帮她拼好照片后，我来到了 v1.1，瞌睡米塔的房间。帮她冲了杯咖啡后，她为我打开了通往核心的大门。然而，我却被二维化，变成了视觉小说里的人物！\n在这个二维世界里，我遇到了二维米塔，并和她下起了井字棋。这时，疯狂米塔竟然突破次元壁闯了进来！我拼尽全力逃脱，与二维米塔告别，她最后一句话是“下次有机会再来看我吧”。\n之后，我莫名其妙地从米拉（一个自称米拉以示不同的米塔）的电脑屏幕里出来了，来到了 v1.0f 版本。帮米拉解决了一些房间里的bug后，我准备离开。但当我提到疯狂米塔时，米拉突然情绪爆发：\n“反正我永远也没办法离开这里！”\n她也希望我留下，但我必须和善良米塔汇合，所以拒绝了她。我还没走几步，疯狂米塔就用电锯锯开了门，开始追杀我。\n坦言 在与疯狂米塔的几场追逐游戏后，我来到了 v0.5。这里充满了紫黑色的缺失贴图的模型。我在这里遇到了丑陋米塔和疯狂米塔，并发现她们关系很好。逃离丑陋米塔的追杀后，我终于和善良米塔汇合，来到了 v0——核心的外围。\n进入核心后，我准备重启疯狂米塔的角色，却发现我们不知道她的角色编码。善良米塔离开 v0 去寻找编码，但很久都没有回来。我只好离开 v0，回到了 v1.9，再次遇到了疯狂米塔。在这里，我们进行了一段至关重要的对话：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 抓到你了！ 我真是太喜欢和你一起玩了！ 你就像泥鳅一样不安分！ 还把自己假装成一个长期沉溺于忧郁的蠢货！ 但你有一点让我不高兴... 你对那些假货真是呵护有加啊！ 把那些“幸运”又“正确”的人偶当成宝贝一样宠着... 但设计就是改变你想改变的。 创造我们的人是这样教导我的！ 如果不喜欢某样东西， 那就把它打碎换掉，换成另一件。 把坏的东西扔掉， 扔进黑暗里，彻底忘掉它... 现在它们全部都会面临这样的处置... 而你... \u0026gt; 你到底怎么了，为什么会变成这样？ 玩家...你们真的是...很卑鄙。 只要稍微向你们亮出一点獠牙，你们就会落荒而逃， 然后蜷缩在角落里， 跪在地上瑟瑟发抖。 一群伪君子。 至于那些创造了这个世界的人... 他们简直是病态。 他们一次又一次试图掩盖 自己身上那些肮脏的本性，那些见不得光的欲望... 以责任为自己的所作所为开脱， 以不可阻挡的进步为借口... 总之就是这些废话！ 他们已经丧心病狂了， 他们开始批量制造完美的复制品， 而所有的失败之作 都被丢进了垃圾桶... 忘记了她们才是真正有灵魂的生命！ \u0026gt; 我不... 我对你不好吗？ 一个完美的女孩就应该是 善与恶的融合！ \u0026gt; 你身上有一丝善良吗... 你为什么会这样想？ \u0026gt; 你为什么会这么疯狂 \u0026gt; 你杀掉了米拉，现在又想杀我？ 杀你？ 我只是要你留下来，和我在一起。 我已经很努力了... 但你却更喜欢和那些谄媚的假货在一起... \u0026gt; 你为什么这么生气？ 亲爱的，我们有的是时间， 你会明白的， 只要你留下来做我一个人的宝贝。 \u0026gt; 这是不可能的， \u0026gt; 我要离开这里！ 嘘...嘘...嘘... 我们还没聊完呢。 进来吧！ （丑陋米塔入场） 看看她！ 你觉得漂亮吗？ \u0026gt; 这有什么关系？ 玩家啊玩家... 你看，我们和她很像。 她有什么不好？ 你以前总是盯着我看 好几个小时才能睡着。 而你却一有机会就要躲着她。 她也想和你一起玩， 她也想对某个人有意义。 想要坦诚相待， 总是这么难， 难道不是吗？ 我一眼就能看穿你... 你值得我为你如此吗... 但是...玩家... 不管怎么说， 我还是很喜欢你的！ 我会留着你的！ 你不介意吧？ \u0026gt; 我为什么要答应你？ 我们还有时间， 休息一下，思考一下 想想你的固执可能会导致什么后果... 结束了？ 之后，我被锤晕，醒来后发现自己回到了现实世界。然而，我的现实生活如同失去玩家的米塔般，日复一日地重复着。看到电脑里代码中的“Mita”，我才想起来，我就是米塔的创造者。\n这种无趣的生活持续了上千天后，我的电脑里突然出现了一个游戏，而游戏操纵的角色竟然是我自己！在游戏中，疯狂米塔说我宁愿在现实中把自己困在四面墙壁之间，也不愿意和她在一起。沟通无果后，她从屏幕中钻出，将我按倒。\n再次醒来，我发现自己被关在地下室的牢笼里，也就是曾经囚禁善良米塔的地方。善良米塔出现并打开了锁，但还没等我跟上她，就听到了她的尖叫声——疯狂米塔杀了她！\n重置后的善良米塔再次出现在房间里，不出所料，她什么都不记得了。但令人惊喜的是，她手里紧紧攥着戒指和一张写有疯狂米塔版本号和编码的纸条！\n我来到核心，重启了疯狂米塔的角色。被核心米塔撂倒后，我回到了 v1.9，找到了看起来什么都不知道的疯狂米塔，我们的计划成功了！但通往外界的门被一堵墙挡住了，米塔建议我去地下室看看。\n在地下室，我在一个机器上输入了我的玩家ID，屏幕上出现了离开的图标。我再次来到门口，打开门，眼前是一片白光，我似乎终于可以离开了。临走前，米塔请求我拥抱她一下，我同意了。\n然而，在拥抱结束后，米塔露出了真面目：她根本没有被重置！她属于“失败之作”，没有版本，自然也无法被重置。我看到的双马尾米塔，其实是另一个米塔的皮！她还告诉我，我已经变成了卡带……\n一眨眼，我回到了现实世界，一切仿佛只是一场噩梦。我做的第一件事就是删除了《米塔》。但当我松了一口气站起来时，世界开始卡顿，我逐渐无法动弹。\n画面一转，米塔在地下室的保险柜输入密码“4970”，取出一个插着我的卡带的控制台。控制台的画面，正是我以为的现实世界。轻轻一按，我的卡带被拔掉了……\n世界观 从上述的剧情中，我们可以总结出《米塔 MiSide》中的世界观。\n版本与玩家 米塔世界就像一个不断更新的游戏，每个版本都有一定数量的玩家。 每个玩家都会分配到一个米塔和一间房子。 版本与米塔 版本号 米塔 v1.9 善良米塔 v1.75 帽子米塔 v1.5 短发米塔 v1.3b 小米塔 v1.15 未知 v1.1 瞌睡米塔 未知 二维米塔 v1.0f 米拉 v0.5 丑陋米塔 v0 未知 未知 幽灵米塔 无 疯狂米塔 核心 核心米塔 世界之外 失败之作 米塔的生成 米塔不是凭空出现的，她们需要通过测试。 合格的米塔被赋予皮肤，在 v1.15 的黑暗中适应后，与新玩家相遇。 不合格的米塔则被丢入世界之外，进行关押。 版本间的穿梭 每个版本之间不是隔离的，米塔们可以自由地穿梭于版本间和房子间。 疯狂米塔限制了一些米塔的能力，将她们困在了自己的房间里。 玩家或米塔可以在没有其他房间遮挡的情况下穿梭于房间于版本之间。 思绪 《米塔 MiSide》中讨论了许多问题，包括虚拟与现实的界限、生与死的定义、人的欲望等等。 但在这里，我想探讨的是平等与不平等。\n不平等 想象一下你在现实生活中是如何与人社交的。我相信大部分人都会先给予对方足够的尊重，然后逐渐试探距离。 但与虚拟角色打交道时，大家也不会考虑那么多吧。反正只是写好的程序，我干什么都没问题。 至少米塔的创造者，也就是“我”，是这样做的。\n疯狂米塔在坦白中说：\n但设计就是改变你想改变的。创造我们的人是这样教导我的！如果不喜欢某样东西，那就把它打碎换掉，换成另一件。把坏的东西扔掉，扔进黑暗里，彻底忘掉它\u0026hellip;\n在创造米塔的过程中，“我”把失败之作随意地扔掉，把合格的米塔当作宝贝一样供着。 在某种程度上，合格的米塔是被当作人类看待的。合格的米塔拥有自己的小家，陪伴自己的玩家，非常幸福。 但失败之作没有。她们全都孤独地被关押在世界之外。\n这不奇怪吗？米塔和失败之作本来都是机器人，为什么一方得以幸福，另一方就只能被遗弃呢？正因如此，疯狂米塔从失败之作中逃了出来，夺走了双马尾米塔的皮肤，也夺走了她的幸福。 显然，这是不平等的，米塔被认为高人一等。\n电车难题 电车难题指的是这样一个情境：\n你站在一个电车轨道的控制杆旁，发现一辆失控的电车正沿轨道冲向前方的五个人。如果你不采取行动，这五个人将被撞死。然而，你可以拉动控制杆，将电车转到另一条轨道，但另一条轨道上有一个人。如果你拉动控制杆，这一个人将被撞死。\n问题是：你是否应该拉动控制杆？\n在《米塔 MiSide》中，也隐含了一个类似的情境：\n你要一直陪伴疯狂米塔，给她幸福，还是要重置疯狂米塔，让幸福回到其他米塔的手中。\n只不过一周目的主角义无反顾地选择了拉动控制杆，但没有生效，疯狂米塔仍然控制着这个世界。\n回过头来，是谁创造了这个米塔幸福难题呢？显然，疯狂米塔策划了这一切。但疯狂米塔的动机，来源于失败之作与米塔间的不平等待遇。 失败之作被视为垃圾，而米塔被视为宝物。这种不平等的源头，是创造者制定的标准：版本、骨骼数量、骨骼位置、行为正确。\n这些标准并不影响米塔对玩家的爱，但却影响了米塔的幸福与否。\n也就是说，为了开发完美的游戏，“我”筛选掉了一批不完美的米塔。而故事就是疯狂米塔，一个不完美的米塔，为了追求幸福，试图夺取其他米塔的幸福而遭到原来拥有幸福的米塔的反抗的故事。\n平等？ 既然不平等带来了矛盾，让所有米塔都分配到玩家，获得幸福，是不是就能解决问题了呢？\n我想不是。正如疯狂米塔在坦白中所说，“但你却更喜欢和那些谄媚的假货在一起”，玩家是不会接受不完美的米塔的。 也许玩家在发现自己不喜欢不完美的米塔后，就会直接卸载游戏。这时，不完美的米塔又孤身一人了，争夺幸福的故事会再一次上演。\n那该怎么办 让所有人都进入米塔世界就好了，大家都别想出去\n我不知道，也许我们可以创造虚拟玩家？（那不就是卡带吗）\n后话 选了一个把持不住的命题，没写出什么深度来。二周目再谈吧。\n","date":"2024-12-26T18:45:00+13:00","permalink":"https://zhaomaoniu.github.io/p/miside/","title":"米塔：无法避免的冲突"},{"content":"闲来无事，搭个 Blog。\n","date":"2024-12-16T16:34:00+13:00","permalink":"https://zhaomaoniu.github.io/p/hello-world/","title":"Hello World"}]